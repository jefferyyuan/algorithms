<Section>Algorithm Questions</Section>Serialization/Deserialization of a Binary Treehttp://www.leetcode.com/2010/09/serializationdeserialization-of-binary.htmlSaving a Binary Search Tree to a Filehttp://www.leetcode.com/2010/09/saving-binary-search-tree-to-file.htmlvoid readBSTHelper(int min, int max, int &insertVal,                   BinaryTree *&p, ifstream &fin) {  if (insertVal > min && insertVal < max) {    int val = insertVal;    p = new BinaryTree(val);    if (fin >> insertVal) {      readBSTHelper(min, val, insertVal, p->left, fin);      readBSTHelper(val, max, insertVal, p->right, fin);    }  }} void readBST(BinaryTree *&root, ifstream &fin) {  int val;  fin >> val;  readBSTHelper(INT_MIN, INT_MAX, val, root, fin);}Serializing General Treeshttp://www.cs.usfca.edu/~galles/cs245/lecture/lecture9.pdfStore an "end of children" markerABDK)))CE)F)GI)J))H)))*3 sum, 3 sum closest, 4 sum*http://en.wikipedia.org/wiki/3SUMGiven a set S of n integers, are there elements a, b, c in S such that a + b + c = n? (n2) sort(S); for i=0 to n-3 do    a = S[i];    k = i+1;    l = n-1;    while (k<l) do       b = S[k];       c = S[l];       if (a+b+c == 0) then          output a, b, c;          exit;       else if (a+b+c > 0) then          l = l - 1;       else          k = k + 1;       end       end end 3Sum ClosestGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.Similiar as before4 SUMhttp://stackoverflow.com/questions/11216582/4sum-implementation-in-java-from-leetcodeInsert into a Cyclic Sorted Listhttp://www.leetcode.com/2011/08/insert-into-a-cyclic-sorted-list.htmlprev→val ≤ x ≤ current→val:x is the maximum or minimum value in the list: Traverses back to the starting point: void insert(Node *& aNode, int x) {  if (!aNode) {    aNode = new Node(x);    aNode->next = aNode;    return;  }   Node *p = aNode;  Node *prev = NULL;  do {    prev = p;    p = p->next;    if (x <= p->data && x >= prev->data) break;   // For case 1)    if ((prev->data > p->data) && (x < p->data || x > prev->data)) break; // For case 2)  } while (p != aNode);   // when back to starting point, then stop. For case 3)   Node *newNode = new Node(x);  newNode->next = p;  prev->next = newNode;}Convert Sorted Array to Balanced Binary Search Tree (BST) - O(N)http://www.leetcode.com/2010/11/convert-sorted-array-into-balanced.htmlGiven an array where elements are sorted in ascending order, convert it to a height balanced BST.BinaryTree* sortedArrayToBST(int arr[], int start, int end) {  if (start > end) return NULL;  // same as (start+end)/2, avoids overflow.  int mid = start + (end - start) / 2;  BinaryTree *node = new BinaryTree(arr[mid]);  node->left = sortedArrayToBST(arr, start, mid-1);  node->right = sortedArrayToBST(arr, mid+1, end);  return node;} BinaryTree* sortedArrayToBST(int arr[], int n) {  return sortedArrayToBST(arr, 0, n-1);}Convert Sorted List to Balanced Binary Search Tree (BST) - O(N)http://www.leetcode.com/2010/11/convert-sorted-list-to-balanced-binary.htmlGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.	As usual, the best solution requires you to think from another perspective. In other words, we no longer create nodes in the tree using the top-down approach. We create nodes bottom-up, and assign them to its parents. The bottom-up approach enables us to access the list in its order while creating nodes. BinaryTree* sortedListToBST(ListNode *& list, int start, int end) {  if (start > end) return NULL;  // same as (start+end)/2, avoids overflow  int mid = start + (end - start) / 2;  BinaryTree *leftChild = sortedListToBST(list, start, mid-1);  BinaryTree *parent = new BinaryTree(list->data);  parent->left = leftChild;  list = list->next;  parent->right = sortedListToBST(list, mid+1, end);  return parent;} BinaryTree* sortedListToBST(ListNode *head, int n) {  return sortedListToBST(head, 0, n-1);}Convert Binary Search Tree (BST) to Sorted Doubly-Linked Listhttp://www.leetcode.com/2010/11/convert-binary-search-tree-bst-to.htmlConvert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list. Determine If Two Rectangles Overlaphttp://www.leetcode.com/2011/05/determine-if-two-rectangles-overlap.htmlThe condition’s expression is:! ( P2.y < P3.y || P1.y > P4.y || P2.x < P3.x || P1.x > P4.x )Using De Morgan’s law, we can further simplify the above expression to:( P2.y = P3.y && P1.y = P4.y && P2.x = P3.x && P1.x = P4.x )http://www.leetcode.com/2010/11/stack-that-supports-push-pop-and-getmin.htmlStack that Support Push, Pop, and GetMin in Constant TimeThe solution is surprisingly simple and elegant — Use an extra stack to maintain the minimums. What does this mean?    To retrieve the current minimum, just return the top element from minimum stack.    Each time you perform a push operation, check if the pushed element is a new minimum. If it is, push it to the minimum stack too.    When you perform a pop operation, check if the popped element is the same as the current minimum. If it is, pop it off the minimum stack too.struct StackGetMin {  void push(int x) {    elements.push(x);    if (minStack.empty() || x <= minStack.top())      minStack.push(x);  }  bool pop() {    if (elements.empty()) return false;    if (elements.top() == minStack.top())      minStack.pop();    elements.pop();    return true;  }  bool getMin(int &min) {    if (minStack.empty()) {      return false;    } else {      min = minStack.top();      return true;    }  }  stack<int> elements;  stack<int> minStack;};Design a queue that supports push_rear, pop_front, and get_min in O(1). Would that be elegantly possible too?	Use two queues.Determine if a Binary Tree is a Binary Search Tree (BST)A binary search tree (BST) is based on binary tree, but with the following additional properties:    The left subtree of a node contains only nodes with keys less than the node’s key.    The right subtree of a node contains only nodes with keys greater than the node’s key.    Both the left and right subtrees must also be binary search trees.Instead of examining all nodes of both subtrees in each pass, we only need to examine two nodes in each pass. As we traverse down the tree from node (10) to right node (15), we know for sure that the right node’s value fall between 10 and +INFINITY. Then, as we traverse further down from node (15) to left node (6), we know for sure that the left node’s value fall between 10 and 15. And since (6) does not satisfy the above requirement, we can quickly determine it is not a valid BST. All we need to do is to pass down the low and high limits from node to node! O(n)bool isBSTHelper(BinaryTree *p, int low, int high) {  if (!p) return true;  if (low < p->data && p->data < high)    return isBSTHelper(p->left, low, p->data) &&           isBSTHelper(p->right, p->data, high);  else    return false;} bool isBST(BinaryTree *root) {  // INT_MIN and INT_MAX are defined in C++'s <climits> library  return isBSTHelper(root, INT_MIN, INT_MAX);}Alternative Solution:Another solution is to do an in-order traversal of the binary tree, and verify that the previous value (can be passed into the recursive function as reference) is less than the current value. This works because when you do an in-order traversal on a BST, the elements must be strictly in increasing order. bool isBSTInOrderHelper(BinaryTree *p, int& prev) {  if (!p) return true;  if (isBSTInOrderHelper(p->left, prev)) {    if (p->data > prev) {      prev = p->data;      return isBSTInOrderHelper(p->right, prev);    } else {      return false;    }  }  else {    return false;  }}http://www.leetcode.com/2011/01/sliding-window-maximum.htmlSliding Window Maximumhttp://www.leetcode.com/2010/11/microsoft-string-replacement-problem.htmlReplace all occurrence of the given pattern to ‘X’.For example, given that the pattern=”abc”, replace “abcdeffdfegabcabc” with “XdeffdfegX”. Note that multiple occurrences of abc’s that are contiguous will be replaced with only one ‘X’.bool isMatch(char *str, const char* pattern) {  while (*pattern)    if (*str++ != *pattern++)      return false;  return true;} void replace(char str[], const char *pattern) {  if (str == NULL || pattern == NULL) return;  char *pSlow = str, *pFast = str;  int pLen = strlen(pattern);  while (*pFast != '\0') {    bool matched = false;    while (isMatch(pFast, pattern)) {      matched = true;      pFast += pLen;    }    if (matched)      *pSlow++ = 'X';    // tricky case to handle here:    // pFast might be pointing to '\0',    // and you don't want to increment past it    if (*pFast != '\0')      *pSlow++ = *pFast++;  // *p++ = (*p)++  }  // don't forget to add a null character at the end!  *pSlow = '\0';}